<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>인텔리제이(IntelliJ) 프로젝트 오픈시 튕김 현상</title>
    <link href="/2021/10/25/%EC%9D%B8%ED%85%94%EB%A6%AC%EC%A0%9C%EC%9D%B4-IntelliJ-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%98%A4%ED%94%88%EC%8B%9C-%ED%8A%95%EA%B9%80-%ED%98%84%EC%83%81/"/>
    <url>/2021/10/25/%EC%9D%B8%ED%85%94%EB%A6%AC%EC%A0%9C%EC%9D%B4-IntelliJ-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%98%A4%ED%94%88%EC%8B%9C-%ED%8A%95%EA%B9%80-%ED%98%84%EC%83%81/</url>
    
    <content type="html"><![CDATA[<p>인프런에서 <strong>김영한</strong>님의 <a href="https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%9E%85%EB%AC%B8-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8#"><strong>스프링 입문 강의</strong></a> 실습을 준비하던 도중 문제가 생겼습니다.</p><p>강의 초반부를 들으며 생긴 문제입니다.</p><blockquote><p>앞서 미리 말하자면 <strong>본 강의에서는 실습 환경으로 jdk 11버전을 권장</strong>합니다. 하지만 전 <strong>jdk 1.8(java 8)버전</strong>을 이용하여 실습을 시도했습니다. 학원에서 수업을 jdk 1.8(java 8) 환경으로 진행하기 때문이죠… ( <a href="https://start.spring.io/">spring initializr</a> 사이트에서도 Java 8 버전을 지원 하기는 합니다.)</p></blockquote><h1 id="인텔리제이가-팅겨요"><a href="#인텔리제이가-팅겨요" class="headerlink" title="인텔리제이가 팅겨요"></a>인텔리제이가 팅겨요</h1><p>문제 발생. 근데 이유를 모릅니다. 그냥 팅깁니다. 과정도 없습니다 그냥 갑자기 냅다 Open Project 가 안됩니다.</p><p> <a href="https://start.spring.io/">spring initializr</a>에서 스프링 부트 패키지를 다운받고, zip파일을 푼 후 인텔리제이에서 Open Project 로 프로젝트를 열어 빌드 하려고 했습니다.</p><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/ef3c05b8-e1cc-4c4c-9860-30c7fffbe62b/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5/20211025/us-west-2/s3/aws4_request&X-Amz-Date=20211025T050231Z&X-Amz-Expires=86400&X-Amz-Signature=4920cdca5141e67a514663a6498313ff4fc0867cbd7e5a356678394f705797fe&X-Amz-SignedHeaders=host&response-content-disposition=filename%20=%22Untitled.png%22" alt="어이없게 생긴 코끼리 아이콘을 빌드해와야 합니다."></p><p>저기 생긴 밋밋한 코끼리 모양 친구(<strong>gradle</strong>라는 버전 관리를 돕는 친구래요)를 열어 build하려 하는데…</p><p>또잉.</p><h2 id="냅다-튕김"><a href="#냅다-튕김" class="headerlink" title="냅다 튕김."></a>냅다 튕김.</h2><p>이 과정을 스크린샷으로 찍을 새도 없이 그냥 냅다. <strong>튕겼습니다.</strong><br>cmd 창을 켜서 확인해보았으나 log에도 남지 않았어요.</p><h3 id="버전이-문제-아님-삽질임"><a href="#버전이-문제-아님-삽질임" class="headerlink" title="버전이 문제? (아님. 삽질임)"></a>버전이 문제? (아님. 삽질임)</h3><p>혹시나 내가 괜히 권장버전이 아니라 구버전을 사용하려 해서 <strong>버전 충돌</strong>이 일어난 건가? 하며,</p><p>저는 그만 <strong>Java (jdk) 버전을 1.8 =&gt; 11로 변경</strong>하기 위한 여정을 떠나버리고야 말았습니다.</p><h4 id="버전-변경-삽질-과정"><a href="#버전-변경-삽질-과정" class="headerlink" title="버전 변경 삽질 과정"></a>버전 변경 삽질 과정</h4><ol><li><a href="https://start.spring.io/">https://start.spring.io/</a> 홈페이지에서 프로젝트를 jdk 11 버전으로 새로 생성하여 다운로드 하고, </li><li>기존 jdk도 oracle에서 11 버전으로 새로 다운 받고 </li><li>환경변수를 다시 셋팅하고</li><li>기도문을 올리고</li><li>무녀복 입고 기도하고</li></ol><p>등등등… 오만난리사우루스를 피웠으나…</p><p>여전히 튕겼습니다!</p><p>아!</p><p>진짜 왜 이럴까? xxx끼…<br>도무지 이유를 찾을 수 없어서 세상을 향해 <em><strong>凸</strong></em> 라도 날리고 싶었습니다! … 결국 지인에게 원격으로 도움 요청을 하여 해결하게 되었습니다. (새벽 1시 반에… 너무나 감사하고 죄송한)</p><h2 id="결국-원인은"><a href="#결국-원인은" class="headerlink" title="결국 원인은?"></a>결국 원인은?</h2><p>jdk 버전 문제가 아니었습니다.<br>원인은 바로 인텔리제이의 <strong>플러그인 충돌 문제</strong>였습니다.</p><p>사실은 처음에 다른 지인분께서 <em>“아무래도 플러그인 충돌 문제 같아요.”</em> 라고 조언 해주었는데… </p><p><em><strong>례?? 플러?그?인??그런?거? 깐 적 없는데 그?럴리가!?</strong></em></p><p>하는 안일한 맘으로 플러그인 설정을 쳐다볼 생각도 못했습니다. (제발 사람이 하는 말을 잘 들읍시다.)</p><p>원인을 알고 나니 억울해서 미춰버릴 뻔했습니다. 저는 정말 플러그인 설정을 건드린 적도 없었고요. 애초에 플러?그?인?? 그게 먼?? 몰??루 였고요. 그냥 인텔리제이를 설치하자마자 Oepn Project 한 게 다인데…</p><p>아무래도 인텔리제이의 가장 <strong>최신 버전(2021.2.3v)</strong> 을 다운한 게 화근이었던 모양입니다. (나온지 2주도 안 된 따끈따끈한 녀석이더라구요.)</p><p>그래요. 어째서인지 <strong>최신버전의 인텔리제이가 실행되면서 플러그인이 모두 자동으로 Enabled 되어버렸고,<br>그 중 하필 충돌이 일어나는 플러그인들까지 모두 Enabled 되어버려 프로젝트가 열리지 않았던 것입니다!</strong> (두둥! 세상에나 기가막혀라)</p><h2 id="그리하여-해결법"><a href="#그리하여-해결법" class="headerlink" title="그리하여 해결법"></a>그리하여 해결법</h2><ol><li>인텔리제이 왼쪽 상단의 <code>Files</code> </li><li>-&gt; <code>settings</code>탭 </li><li>-&gt; <code>plugin</code>에 들어간 후</li><li>Installed 된 플러그인들을 <strong>Disable all</strong> 해주고</li><li>다시 <strong>Enabled all</strong> 해주었습니다 </li><li>그러면 알아서 충돌이 나는 플러그인을 잡아서 <em>“얘 충돌난단다!”</em> 하는 오류 메세지 창이 뜹니다. </li><li><strong>오류가 나는 플러그인을 Disable</strong> 해주면 오류 해결! </li></ol><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/00afca25-9550-4a5e-9129-c9c5ba7d2f37/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5/20211025/us-west-2/s3/aws4_request&X-Amz-Date=20211025T055857Z&X-Amz-Expires=86400&X-Amz-Signature=c13b9a5facb60f03f5b47cdb5030adc7698d980032c7bef20336378d71eb87e8&X-Amz-SignedHeaders=host&response-content-disposition=filename%20=%22Untitled.png%22" alt="이것도 제가 아니라 멋쟁이 지인분께서 뚝딱똑딱 해주셨고, 저는 그저 천재와 방탈출카페를 간 바보처럼 화면을 바라보며 박수를 쳤습니당 와항하"></p><hr><p><img src="https://pbs.twimg.com/media/EQ-FctrVAAAsiGt.jpg" alt="아무튼 해결."></p><p>모든 인텔리제이 최신 버전에서 이런 문제(자동으로 플러그인이 모두 활성화되는 겁나 어이없는 일)가 일어나는지는 모르겠습니다. 아무튼 저에게는 일어났고 저는 개킹받았거든요… 그래서 포스팅을 꼭 하고 싶었습니다.</p><blockquote><p>혹시나 저처럼 도대체 어떠한 이유로 튕겼는지 도무지 모를 때<br><strong>플러그인을 의심</strong>해봅시다. </p></blockquote><p>플러그인이 아니라면 인텔리제이의 버전 업데이트일을 확인해보고 그 이전 버전을 다운로드 해봅시다. <del>그래도 안되면 주변 사람을 붙잡고 울어봅시다</del> </p><h2 id="오늘의-교훈"><a href="#오늘의-교훈" class="headerlink" title="오늘의 교훈"></a>오늘의 교훈</h2><ol><li>구관이 명관이다</li><li>도저히 모르겠으면 울 시간에 질문하자. (흰 천과 바람이 있으면 항복을 할 수 있어요. 항해가 아니고.)</li></ol><p>아무튼 행복하세요. 꾸벅.</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>공부</tag>
      
      <tag>스프링</tag>
      
      <tag>삽질</tag>
      
      <tag>버그</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>버텨내는 삶에 대하여</title>
    <link href="/2021/10/20/%EB%B2%84%ED%85%A8%EB%82%B4%EB%8A%94-%EC%82%B6%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC/"/>
    <url>/2021/10/20/%EB%B2%84%ED%85%A8%EB%82%B4%EB%8A%94-%EC%82%B6%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC/</url>
    
    <content type="html"><![CDATA[<p>자바 웹개발 과정으로 국비 학원을 다닌 지 벌써 1달이 다 되어갑니다. </p><p>9월 28일이 개강이었는데 어느덧 10월 20일이 되었네요.<br>중간에 임시 휴무와 기능사 필기 시험 일정이 이상하게 겹쳐서 한 주를 통째로 쉬기도 했습니다. (시험은 합격했구 쉬는 동안은 집에서 자습을 했어요.)</p><p>저희 집에서 학원까지는 대중교통을 이용하여 1시간 10분 정도가 걸려요.<br>9시에 출석을 하려면 늦어도 7시 40분에는 차를 타야 합니다.<br>게다가 저는 학원 다니기 전부터 <strong>아침 공복 요가</strong>라는 루틴을 지켜오고 있었는데요, 이 루틴을 지켜내기 위해서는 온전히 요가에 집중할 30분이 필요하고, 또 나갈 준비를 하는 동안 허둥지둥 하고 싶지 않고… 이런 저런 이유로 그냥 학원 가는 날은 매일 아침 5시 40분에 기상하고 있습니다.</p><hr><h3 id="초겨울의-새벽-5시-40분은-정말-춥습니다"><a href="#초겨울의-새벽-5시-40분은-정말-춥습니다" class="headerlink" title="초겨울의 새벽 5시 40분은 정말 춥습니다."></a>초겨울의 새벽 5시 40분은 정말 춥습니다.</h3><p>으슬으슬함을 견디고 요가 매트 위에서 팔다리를 유연하게 움직이다 보면 어느새 조금 온기가 돕니다. 어둑어둑하던 집도 요가를 하는 동안 동이 트면서 점점 밝아져요. 제가 제일 좋아하는 시간입니다.</p><p>원래는 이 시간에 나가 걷는 것을 좋아했습니다. 동이 트기 직전의 하늘색은 정말 오묘하고, 거리엔 정말 아무도 없거든요. 한 시간이고 두 시간이고 걷다 보면 하늘은 밝아지고 저뿐이던 거리에도 인기척이 생깁니다. 그렇게 걸으면서 실없는 생각도 하고 일기를 쓰기도 하지요.</p><p>요즘은 그렇게 걸을 시간은 많이 없지만, 요가를 하며 매일 동이 트는 순간을 누릴 수 있다는 건 좋은 것 같아요. 정말이지 하루에서 제가 제일 아끼는 시간이에요. 매일 아침을 기분 좋게 시작합니다. (사실은 한두 번 빼먹기도 했어요. <del>비밀임</del>)</p><p>요즘 학원에서는 <strong>Linux OS</strong>에서 <strong>Oracle SQL</strong>을 다루는 법, <strong>Java</strong> 기초문법. 그리고 <strong>JavaScript</strong>에 대해서 배우고 있습니다.<br>아직 까지는 공부해왔던 내용이라 아주 어렵진 않아요. 이제 곧 JSP 시간에 <strong>JSP &amp; Servlet</strong> 교재로 진도를 나갈 텐데, 이쪽에 대해선 하나도 예습하지 않아서 요즘 조금씩 교재를 읽어보고 있습니다.</p><p><strong>웹 표준(html)</strong> 시간에는 그냥 마음 편히 자습을 해요. (불량하다!)</p><hr><p>여태껏 웹이랑 나름 친한 사이라고 생각했는데, 새삼… 배우며 느끼는 거지만 생각보다 저희는 데면데면한 사이였어요.</p><blockquote><p><em>웹 : 우리 친구였냐?<br>그 저기 미안…</em></p></blockquote><p>아무튼 요즘은 오직 프론트만 생각할 때는 몰랐던 것이 점점 보이고 있습니다. 즐거워요. 여태까진 검색 버튼을 누르면 백(이름도 back이라 뭔가 어둠의 조직 같았습니다.)에서 뭔가 멋진 마법이 일어나서 검색 결과 페이지를 넘겨주는 줄로만 알았어요. 직접 그 마법의 원리에 대해 이해하고 탐구해볼 생각은 못 했습니다. 저는 뭔가 새로운 지식을 배우기를 굉장히 주저했거든요. 하지만 막상 알아가보게 되니 재밌습니다. 더 멀리, 더 많이 볼 수 있어요.</p><p>프로그래밍 공부를 시작하고는, 도전을 두려워하던 제 성격이 조금씩 변하고 있다고 실감하고 있어요. 막상 새로운 걸 배우게 되면 정말 즐겁다는 걸 알아버렸거든요. 그리고는 넘어지는 걸 좀 덜 두려워하게 됐어요. 넘어지는 건 웃겨 보일 거라고 생각했는데, 생각보다 넘어지는 건 멋진 일이었습니다. 일단 넘어질 수도 있다는 걸 알면서도 달린다는 것 자체로 정말 굉장해요. 그리고 놀랍게도 넘어짐으로써 얻게 되는 것들도 있습니다. 삽질하면 팔에 근육이 붙는 것처럼 사이버 삽질도 마냥 의미가 없는 일은 아니었습니다. 되어볼까 사이버 몸짱.</p><p>그래서 저는 요즘 즐거워요. 한 달 전의 불안해하던 제가 떠오를 때면 가여워요. 걱정 말라고 잘 하고 있다고 말을 해주고 싶어요.</p><p>예전 일기장에 이런 말을 써뒀더라구요. <em>“사랑은 사람을 약하게 만들어. 나는 그냥 하고 싶은 일을 할 때가 좋아. 하고 싶은 일을 할 때 난 강해져.”</em><br>2017년의 저는 그랬나 봐요. 물론 지금도 하고 싶은 일을 하는 저는 강합니다. 하지만 사랑을 하는 저도 강해요. 저는 저를 강하게 만드는 것들을 사랑할 줄 아는 사람이 되었나 봅니다. 저를 힘 나게 하는 사람들을 사랑하고 제가 하는 일들을 사랑해요. 물론 완벽하지는 않습니다.</p><p>2021년의 저는 여전히 자주 넘어져요. 느림보 걸음을 걷구요. 그럼에도 마음이 약해지는 신호가 오면 커피를 마십니다. 그리고 요가를 해요. 강해지기 위해서요. 그럼에도 넘어지면 그냥 누워서 하늘을 봐요. 그렇게 그냥 일어나고 싶을 때까지 누워 있어요. 왜냐면 그래도 괜찮다는 걸 아니까요. 저는 언제까지고 제가 원할 때까지 바닥에 기대있을 수 있죠. 그걸 알고 나니 세상에 기댈 곳이 많아졌습니다.</p><hr><p>전 늘 자신에 대한 확신이 없고 불안한 상태였어요.</p><p>내가 잘 할 수 있을까?<br>우유부단하고,<br>이성적이지도 못하고, 논리적이지도 못하고<br>인생을 늘 이상한 방식으로 살아와 놓고서는…<br>이제 와서 개발자가 될 수 있을까?</p><p>사실은 지금도 불안합니다. 불안하지만서도, 그냥 그런 이상한 개발자가 되어보고 싶어요. 자주 넘어져서 무릎엔 멍이 들어 있고, 눈물이 많고, 우산에 이름을 붙여주고, 밤에는 달을 보며 산책하는 이상한 개발자가 되어보고 싶다고 생각합니다.</p><p>하루 아침에 똑순이 야무쟁이로 변신할 자신은 없지만… 여전히 개발은 즐거워요. 뭔가를 배우고 그걸로 만들어내는 게 즐거워요.<br>앞으로도 저는 재밌는 걸 할 거예요. 좋아하는 일을 하고 싶어요. 지금처럼. 그럼 안 되는 걸까요?</p><p>언젠가 이 일이 저를 너무 괴롭게 한다면 저는 미련 없이 개발을 그만둘 거예요. 그리고 원할 때 다시 공부할 거예요.</p><p>그래도 괜찮다는 걸 알아요. 이제는.</p><p>그냥… 단지 저는<br>남은 삶을 잘 버텨내고 싶어요.</p><p>이것을 회고라고 해도 될까요?<br>마칠게요.</p>]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
      <category>Retrospect</category>
      
    </categories>
    
    
    <tags>
      
      <tag>국비교육</tag>
      
      <tag>푸념</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>자바의 제네릭(Generic)</title>
    <link href="/2021/10/07/%EC%9E%90%EB%B0%94%EC%9D%98-%EC%A0%9C%EB%84%A4%EB%A6%AD/"/>
    <url>/2021/10/07/%EC%9E%90%EB%B0%94%EC%9D%98-%EC%A0%9C%EB%84%A4%EB%A6%AD/</url>
    
    <content type="html"><![CDATA[<p>오늘은 제네릭에 대해 학습했다. 학습하면서도 아리까리한 게 많아 복습할 겸 포스팅을 남긴다. 제네릭… 어렵다. 제네릭 개xx야. 개 xx.이xxx한 xxx놈아…!</p><p>진정하고 시작하자.</p><h1 id="제네릭의-정의"><a href="#제네릭의-정의" class="headerlink" title="제네릭의 정의"></a>제네릭의 정의</h1><p>사전에서 <strong>Generic</strong>을 찾아보면 <em>‘일반적인, 포괄적인’</em> 으로 표기되어 있다. 자바에서의 제네릭이 의미하는 바도 크게 다르지 않다.<br>제네릭은 자바의 수많은 자료형들, 그 중에서도 <strong>포괄적</strong>이고 <strong>일반적</strong>인 형식을 의미한다.</p><p>내가 좋아하는 한 아이돌 육성 게임(ㅎㅎ)을 예시로 들며 제네릭에 대해 설명해보겠다.<br>지금부터 타입별로 아이돌을 육성하는 프로그램을 개발한다고 생각해보자.</p><h2 id="아이돌-육성-프로젝트ㅎㅎ"><a href="#아이돌-육성-프로젝트ㅎㅎ" class="headerlink" title="아이돌 육성 프로젝트ㅎㅎ"></a>아이돌 육성 프로젝트ㅎㅎ</h2><ul><li><p>아이돌은 각 <strong>3가지 타입 중 하나</strong>를 고유하게 가지고 있다.  </p><ul><li>보컬</li><li>댄스</li><li>비주얼</li></ul><p>  이 특성들을 클래스로 만들 것이다.</p></li><li><p><code>스카우트</code> 클래스에서 아이돌의 타입을 가져(<code>get</code>)오거나, 설정(<code>set</code>)해줄 수 있다.<br>먼저 <code>보컬</code>이 특기인 아이돌을 스카우트하는 <code>Scout</code> 클래스를 생성한다고 해보자.</p><blockquote><p>Scout Class <strong>보컬</strong>편!</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Scout</span> </span>&#123;<br>  pritave Vocal type;<span class="hljs-comment">// type 변수를 Vocal형으로 선언</span><br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setType</span><span class="hljs-params">(Vocal type)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.type = type;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Vocal <span class="hljs-title">getType</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> type;  <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>  좋다. 그런데 아직 두 타입이 남았다. 이 두 타입의 메서드는 크게 다를까?<br>Scout Class <strong>댄스</strong>편!</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Scout</span> </span>&#123;<br>  pritave Dance type;<span class="hljs-comment">// type 변수를 Dance형으로 선언</span><br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setType</span><span class="hljs-params">(Dance type)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.type = type;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Vocal <span class="hljs-title">getType</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> type;  <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Scout Class <strong>비주얼</strong>편!</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Scout</span> </span>&#123;<br>  pritave Visual type;<span class="hljs-comment">// type 변수를 Dance형으로 선언</span><br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setType</span><span class="hljs-params">(Visual type)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.type = type;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Vocal <span class="hljs-title">getType</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> type;  <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>  코드를 보면 그냥 각 참조자료형(3 Type)만이 달라졌을 뿐, 결국 <code>get</code> 하고 <code>set</code> 하는 기능은 달라지지 않았다. 이런 식의 반복되는 코드는 지양하는 것이 좋다. </p></blockquote></li></ul><h3 id="잠깐-이전에-학습한-다형성을-활용해서-생각해보자"><a href="#잠깐-이전에-학습한-다형성을-활용해서-생각해보자" class="headerlink" title="잠깐! 이전에 학습한 다형성을 활용해서 생각해보자."></a>잠깐! 이전에 학습한 <strong>다형성</strong>을 활용해서 생각해보자.</h3><p><code>Scout</code> 클래스가 <code>type</code>의 자료형을 Vocal, Dance, Visual이 아니라<br>상위 클래스인 <code>Object</code>로 선언한다면?<br>이 세 가지의 class 뭉텅이를 하나로 합칠 수 있을 것이다. 살펴보자.</p><blockquote><p>Object를 활용한 Scout 클래스</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Scout</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> Object type;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setType</span><span class="hljs-params">(Object type)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.type = type;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getType</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> type<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>위와 같이 Scout 클래스에 Object형을 type으로 선언하면 아래와 같이 사용할 수 있다.</p><blockquote><p> test</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Scout scout = <span class="hljs-keyword">new</span> Scout();<br><br>Vocal t1 = <span class="hljs-keyword">new</span> Vocal();<br>scout.setType(t1);<span class="hljs-comment">// 여기서 Object 형으로 자동 형변환 된다.</span><br><br>Vocal t2 = (Vocal)scout.getType();<span class="hljs-comment">// 직접 형변환을 해줘야 한다.</span><br></code></pre></td></tr></table></figure><p>아까보다 코드가 간결해지긴 했다.<br>하지만 마지막 줄을 보자.<br>어떤 변수가 여러 참조형을 사용할 수 있도록 <code>Object</code> 클래스를 사용하면,<br>다시 <strong>원래 자료형으로 반환받을 때는 매번 형변환</strong>을 해야하는 번거로움이 있다.</p><p>이러한 ==<strong>캐스팅의 번거로움을 줄이기 위해</strong> 사용하는 프로그래밍 방식==이 바로 <strong>제네릭</strong>이다.<br>제네릭은 여러 참조형을 사용해야 하는 부분에 <code>Object</code> 대신 **&lt;하나의 문자&gt;**로 표현한다.</p><p>이제 제네릭을 사용해보자.</p><h2 id="제네릭-클래스-정의하기"><a href="#제네릭-클래스-정의하기" class="headerlink" title="제네릭 클래스 정의하기"></a>제네릭 클래스 정의하기</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericScout</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">private</span> T type;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setType</span><span class="hljs-params">(T type)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.type = type;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getType</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> type<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>제네릭은 클래스 명 뒤에 다이아몬드 연산자 <code>&lt;&gt;</code> 를 사용하여 정의할 수 있으며, 예시에서 선언한  <code>&lt;T&gt;</code>는 <strong>Type</strong>의 약자이고 이를 <strong>자료형 매개변수</strong> 라고 부른다.<br>나중에 클래스를 사용할 때 다이아몬드 연산자 안에 <strong>&lt;실제 사용할 자료형&gt;</strong> 을 지정한다.</p><p>T말고도 선언부에서 자료형을 대충 구분할 수 있는 여러 문자들이 있다.</p><table><thead><tr><th>Type</th><th>Info</th></tr></thead><tbody><tr><td><code>&lt;T&gt;</code></td><td>Type</td></tr><tr><td><code>&lt;E&gt;</code></td><td>Element</td></tr><tr><td><code>&lt;K&gt;</code></td><td>Key</td></tr><tr><td><code>&lt;V&gt;</code></td><td>Value</td></tr><tr><td><code>&lt;N&gt;</code></td><td>Number</td></tr></tbody></table><p>이것들은 모두 암묵적 규칙일 뿐,<br>사실 &lt;&gt; 안에 멋대로 원하는 문자를 써도 오류는 나지 않는다.<br>하지만 협업 시 헷갈림을 방지하기 위해서라도 규칙은 지켜주는 게 좋다.</p><h2 id="제네릭-클래스-사용하기"><a href="#제네릭-클래스-사용하기" class="headerlink" title="제네릭 클래스 사용하기"></a>제네릭 클래스 사용하기</h2><p><code>Vocal</code> 타입을 스카우트하기 위해서는 다음과 같이 <strong>제네릭 클래스</strong>를 사용한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">GenericScout&lt;Vocal&gt; vocalScout = <span class="hljs-keyword">new</span> GenericScout&lt;Vocal&gt;();<br>vocalScout.setType(<span class="hljs-keyword">new</span> Vocal());<br>Vocal vocal = vocalScout.getType();<span class="hljs-comment">// 명시적 형변환을 해줄 필요가 없다</span><br></code></pre></td></tr></table></figure><p>아까 <code>Object</code> 클래스를 사용할 때와 다르게 타입을 <code>get</code> 해올 때 <strong>자료형 캐스팅을 해주지 않아도 된다.</strong></p><p><code>Scout&lt;Vocal&gt;</code> 에서 어떤 자료형을 사용할지 미리 명시했음으로 <code>getType()</code> 메서드에서 타입을 반환할 때 <strong>형변환이 일어나지 않아도 정상적으로 <code>Vocal</code> 타입이 반환이 된다.</strong></p><p><code>Scout&lt;Vocal&gt;</code> 에서 <code>&lt;T&gt;</code>에 위치한 <code>Vocal</code>형을 <strong>대입된 자료형</strong> 이라고 하고,<br><code>Vocal</code>형을 대입해 만든 <code>GenericScout&lt;Vocal&gt;</code>을 <strong>제네릭 자료형</strong> 이라고 한다.</p><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td><code>GenericScout&lt;Vocal&gt;</code></td><td>제네릭 자료형, 매개변수화된 자료형</td></tr><tr><td><code>&lt;Vocal&gt;</code></td><td>대입된 자료형</td></tr></tbody></table><h2 id="대입에-사용할-자료형을-제한하는-방법"><a href="#대입에-사용할-자료형을-제한하는-방법" class="headerlink" title="대입에 사용할 자료형을 제한하는 방법"></a>대입에 사용할 자료형을 제한하는 방법</h2><p>제네릭 클래스에서 T자료형에 사용할 자료형에 제한을 둘 수 있다.<br>제약을 두지 않으면 <code>Vocal</code>, <code>Dance</code>, <code>Visual</code> 타입이 아니라, <strong>뜬금 없는 <code>Tuna</code>(참치) 타입, <code>Ninja</code>(닌자) 타입 아이돌이 스카웃 될 수 있다.</strong><br>물론, 살다보면 또 <a href="https://namu.wiki/w/%EC%95%84%EC%82%AC%EB%A6%AC%20%EB%82%98%EB%82%98%EB%AF%B8">이런…</a> <a href="https://namu.wiki/w/%ED%95%98%EB%A7%88%EA%B5%AC%EC%B9%98%20%EC%95%84%EC%95%BC%EB%A9%94">저런…</a> 일들이 일어날 수도 있다. 하지만 우리는 그것을 방지하고 싶다. 그렇다면 ==사용할 클래스에 자료형 제한을 두기 위해 <code>extends</code> 예약어==를 사용할 수 있다.</p><ol><li>우선 GenericScout<T> 클래스에서 T에 ‘대입된 자료형’으로 사용할 재료 클래스 <code>Type</code>를 추상클래스로 만든다. 그리고 추상 메서드도 하나 만들어주자. <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doScouting</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure> 여기서 선언한 추상 메서드를 반드시 구현해야 한다.</li><li>그리고 각각 <code>Vocal</code> <code>Dance</code> <code>Visual</code> 을 <code>Type</code> 클래스에서 상속받게끔 한다. 추상 메서드도 여기서 구현한다.<blockquote><p>Vocal 클래스 </p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vocal</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Type</span> </span>&#123;<br>  <span class="hljs-comment">// 추상메서드 구현</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doScouting</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;Vocal 아이돌을 스카웃 합니다.&quot;</span>)<br>  &#125;<br>  <br>  <span class="hljs-comment">// 기존 메서드 오버라이드</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;타입은 Vocal 입니다.&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Dance 클래스 </p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dance</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Type</span> </span>&#123;<br>  <span class="hljs-comment">// 추상메서드 구현</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doScouting</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;Dance 아이돌을 스카웃 합니다.&quot;</span>)<br>  &#125;<br>  <br>  <span class="hljs-comment">// 기존 메서드 오버라이드</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;타입은 Dance 입니다.&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Visual 클래스 </p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Visual</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Type</span> </span>&#123;<br>  <span class="hljs-comment">// 추상메서드 구현</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doScouting</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;Visual 아이돌을 스카웃 합니다.&quot;</span>)<br>  &#125;<br>  <br>  <span class="hljs-comment">// 기존 메서드 오버라이드</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;타입은 Visual 입니다.&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li><li>테스트 해봅시다. <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericScout&lt;T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Type&gt;</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">T</span> <span class="hljs-class"><span class="hljs-keyword">type</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure> 이렇게 클래스이름에 <code>GenericScout&lt;T extends Type&gt;</code> 라고 명시하여 제한을 두면, ==Type class를 상속받지 않는 <code>Ninja</code> 클래스나 <code>Tuna</code> 클래스를 넣을 시 오류가 발생한다.==<br> 또 저렇게 extends로 확장해온 class는 ==확장해온 Type클래스에서 선언한 메서드도 그대로 사용할 수 있다.== 그러니 아까 <code>Vocal</code>, <code>Dance</code>, <code>Visual</code>에서 각각 정의한 <code>doScouting()</code> 메서드를 그대로 사용할 수 있다는 거다.</li></ol><h2 id="제네릭의-장점-정리-땅땅"><a href="#제네릭의-장점-정리-땅땅" class="headerlink" title="제네릭의 장점 정리 땅땅"></a>제네릭의 장점 정리 땅땅</h2><ol><li><code>extends</code> 예약어를 통해 <strong>잘못된 타입이 들어오는 것을 컴파일 단계에서 방지</strong>할 수 있음.</li><li>클래스 외부에서 타입을 지정하기 때문에 <strong>명시적 타입 변환에 신경쓰지 않아도 됨.</strong></li><li>당연한 얘기지만, <strong>코드의 재사용성이 높아짐.</strong></li></ol><hr><p>여태까진 제네릭 클래스에 대해서 다뤄보았다. 다음엔 제네릭 메서드의 활용에 대해서 다뤄보겠다. 오늘 둘 다 하기에는 내.기력.이.소.진됨..<br>아이돌 픽업하러 가야지</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>공부</tag>
      
      <tag>자바</tag>
      
      <tag>제네릭</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>생각에 설탕치기</title>
    <link href="/2021/10/04/%EA%B0%90%EC%A0%95%EC%9D%84-%EA%BE%B9%EA%BE%B9-%EB%88%8C%EB%9F%AC-%EB%8B%B4%EC%95%84-%EC%84%A4%ED%83%95%EC%97%90-%EC%A0%88%EC%9D%B4%EB%A9%B4/"/>
    <url>/2021/10/04/%EA%B0%90%EC%A0%95%EC%9D%84-%EA%BE%B9%EA%BE%B9-%EB%88%8C%EB%9F%AC-%EB%8B%B4%EC%95%84-%EC%84%A4%ED%83%95%EC%97%90-%EC%A0%88%EC%9D%B4%EB%A9%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="설탕-팍팍-친-블로그"><a href="#설탕-팍팍-친-블로그" class="headerlink" title="설탕 팍팍 친 블로그"></a>설탕 팍팍 친 블로그</h1><p>이 블로그는 정적 블로그 생성 툴 <a href="https://hexo.io/ko/index.html">Hexo</a> 로 만든 나의 귀여운 블로그.</p><p>정적 블로그 생성 툴 <strong>Hexo</strong>의 존재를 알려준 <a href="https://hatchling13.github.io/">해츨링</a>님 감사합니다 ✨😊<br>링크거는 거 신기해서 괜히 막 막 걸어보기ㅋㅋ</p><hr><p>전부터 일기를 쓸 때면 종종 일기장들을 차곡차곡 모아서<br>잼병에 담가 푹 절이는 생각을 했다!<br>왜냐면 재밌으니까 헤헤</p><p>그니까… 여긴… 이제부터<br>나애 소중한 ✨<strong>싸이버 쨈보틀</strong>✨…이 된 것이돠…</p><p>나중에 병모양의 디자인으로 수정해보는 것도 재밌겠다.<br>헐~ 짱 재밌겠는데? 막 오래된 글 숙성시키구?<br>물론 시간이 날 때의 얘기지만</p><hr><p>무튼 이제 블로그도 생겼으니<br>회고라는 것도 써보고 싶고,<br>일기도 써보고 싶고…<br>배운 것들도 기록하고 싶고…</p><p>하고 싶은 게 많다!</p><p>근데 당장 낼모레가 자격증 시험인데 휴…<br>기출 몇번 돌리긴 했지만. 걱정이 되는군…</p><p>난 바쁠 때 왜 이렇게 딴짓에 진심이 되는 것임</p><p>아무튼<br>아무튼간에!<br>나의 블로그 안녕!!</p><h3 id="헬로월드-냥냐"><a href="#헬로월드-냥냐" class="headerlink" title="헬로월드 ~ 냥냐 ~"></a><em>헬로월드 ~ 냥냐 ~</em></h3><p>사실 월드라기엔<br>에게… ~~<br>약간… 읍/면/리 이쪽,,, 같지만…</p><p>아무튼 이곳에<br>이것저것 써내리구<br>설탕 도 막 팍팍 치고<br>마 아무튼 최선을 다해볼 것이다<br>😠😣 </p>]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>딸기쨈</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
